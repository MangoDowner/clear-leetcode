# 堆排序
### 解题思路
构造优先队列，底层基于数组，每次都把最大值拿到最后面去

是一种特殊的树形数据结构，其每个结点都有一个值，通常提到的堆都是指一棵``完全二叉树``，
根结点的值小于（或大于）两个子结点的值，同时，根结点的两个子树也分别是一个堆。

堆排序是一树形选择排序，在排序过程中，将``R[1…n]``看成是一颗完全二叉树的顺序存储结构，
利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。

堆排序的思想是对于给定的n个记录，初始时把这些记录看作一棵顺序存储的二叉树，
然后将其调整为一个大顶堆，将堆的最后一个元素与堆顶元素（即二叉树的根结点）进行交换后，
堆的最后一个元素即为最大记录；
接着将前(n-1)个元素（即不包括最大记录）重新调整为一个大顶堆，
再将堆顶元素与当前堆的最后一个元素进行交换后得到次大的记录，
重复该过程直到调整的堆中只剩一个元素时为止，该元素即为最小记录，
此时可得到一个有序序列。

堆排序主要包括两个过程：
* 一是构建堆；
* 二是交换堆顶元素与最后一个元素的位置。

### 代码
```golang
func heapSort(arr []int) {
	l := len(arr)
	// 构造大顶堆
	// 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1
	for i := l/2 - 1; i >= 0; i-- {
		adjustHeap(arr, i, l)
	}
	// 循环不变量：区间 [0, i] 堆有序
	for i := l - 1; i > 0; i-- {
		// 把堆顶元素（当前最大）交换到数组末尾
		arr[0], arr[i] = arr[i], arr[0]
		// 逐步减少堆有序的部分
		// 重新对堆进行调整
		adjustHeap(arr, 0, i)
	}
}

// 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
func adjustHeap(arr []int, start, length int) {
	temp := arr[start] // 取出当前元素i
	//从i结点的左子结点开始，也就是2i+1处开始
	for i := start*2 + 1; i < length; i = i*2 + 1 {
		//如果左子结点小于右子结点，k指向右子结点
		if i+1 < length && arr[i] < arr[i+1] {
			i++
		}
		//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
		if arr[i] > temp {
			arr[start] = arr[i] // 将当前的最大值赋值给start位置
			start = i           // 记录当前最大值索引
		} else {
			break
		}
	}
	// 当最开始start位置的值换到最后的子节点去
	arr[start] = temp
}
```