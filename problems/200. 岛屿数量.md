# 广度优先遍历
### 解题思路
* 1.遍历grid
* 2.如果是``水``，跳过
* 3.如果是``陆地``，则将其加入搜索队列尾部，岛屿数量``+1``
* 4.遍历搜索队列，将队列中``陆地``的``上下左右``的邻居陆地全部加入搜索队列，加入后，将其置为``水``，防止重复计算

为啥是上下左右呢？难道只搜索``右``和``下``不够嘛？

不够。如果不四个方向全部搜索，像下面这张图里蓝色的陆地就要第二次搜索队列才能找到，平白无故多出一个岛来。
![image.png](https://pic.leetcode-cn.com/7d005290cb9189ba09334c889998a2ae3d4f4f5bd0fe62dad41546f10b93f4be-image.png)

* 5.直到搜索队列清空后，继续执行1/2/3/4操作

### 代码

```golang
func numIslands(grid [][]byte) int {
	rowNum := len(grid)
	if rowNum == 0 {
		return 0
	}
	colNum := len(grid[0])
	num := 0
	for r, v := range grid {
		for c, v1 := range v {
			// 如果是水，不用管
			if v1 == '0' {
				continue
			}
			num++
			connected := [][]int{{r, c}} // 相连的陆地
			for len(connected) != 0 {
				top := connected[0] // 取出队列头部的元素
				connected = connected[1:]
				row, col := top[0], top[1]
				if row-1 >= 0 && grid[row-1][col] == '1' { // 上
					connected = append(connected, []int{row - 1, col})
					grid[row-1][col] = '0'  // 为了不重复计算，全部清0
				}
				if col+1 < colNum && grid[row][col+1] == '1' { // 右
					connected = append(connected, []int{row, col + 1})
					grid[row][col+1] = '0'
				}
				if row+1 < rowNum && grid[row+1][col] == '1' { // 下
					connected = append(connected, []int{row + 1, col})
					grid[row+1][col] = '0'
				}
				if col-1 >= 0 && grid[row][col-1] == '1' { // 左
					connected = append(connected, []int{row, col - 1})
					grid[row][col-1] = '0'
				}
			}

		}
	}
	return num
}
```