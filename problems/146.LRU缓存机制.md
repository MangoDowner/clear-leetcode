# 双向链表
> 原题链接：[146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)
## 双向链表
### 解题思路
参照labuladong大佬的[LRU 策略详解和实现](https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/)

### 代码
```golang
type LRUCache struct {
	Cache      map[int]*DoubleLink
	Size, Cap  int
	Head, Tail *DoubleLink
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		Cache: map[int]*DoubleLink{},
		Cap:   capacity,
		Head:  NewDoubleLink(0, 0),
		Tail:  NewDoubleLink(0, 0),
	}
	l.Head.Next = l.Tail
	l.Tail.Prev = l.Head
	return l
}

func (this *LRUCache) Get(key int) int {
	node, ok := this.Cache[key]
	if !ok {
		return -1
	}
	this.MoveToHead(node)
	return node.Value
}

func (this *LRUCache) Put(key int, value int) {
	node, ok := this.Cache[key]
	if ok {
		node.Value = value
		this.MoveToHead(node)
		return
	}
	node = NewDoubleLink(key, value)
	this.Cache[key] = node
	this.AddToHead(node)
	this.Size++
	// 处理下超出容量的问题
	if this.Size <= this.Cap {
		return
	}
	this.RemoveTail()
	
}

func (this *LRUCache) AddToHead(node *DoubleLink) {
	node.Prev = this.Head
	node.Next = this.Head.Next
	this.Head.Next.Prev = node
	this.Head.Next = node
}

func (this *LRUCache) MoveToHead(node *DoubleLink) {
	this.RemoveNode(node) // TODO
	this.AddToHead(node)
}

func (this *LRUCache) RemoveNode(node *DoubleLink) {
	node.Prev.Next = node.Next
	node.Next.Prev = node.Prev
}

func (this *LRUCache) RemoveTail() {
	node := this.Tail.Prev
	this.RemoveNode(node)
	delete(this.Cache, node.Key)
	this.Size--
}

type DoubleLink struct {
	Key, Value int
	Prev, Next *DoubleLink
}

func NewDoubleLink(key, value int) *DoubleLink {
	d := new(DoubleLink)
	d.Key = key
	d.Value = value
	return d
}
```