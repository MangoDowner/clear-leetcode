# 41.缺失的第一个正数
> 原题链接：[41.缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

## 哈希表法
###  解题思路
这道题首先能想到的解法应该是给建立个哈希表``map``，然后遇到正数，就把对应的``map[key]``设置好，最后``key``从1开始遍历，看看第一个哈希表中第一个缺失的正数是谁就好了。

但是，这样不满足题目所说的空间复杂度为``O(1)``的要求，那么就考虑下，有没有其他办法替换哈希表？实现哈希表可以提供的``快速查找``功能，我们可以考虑将给定的数组设计成哈希表的``替代产品``。

* 1、``nums``数组长度为``l``，哪怕存的都是最小的正整数，那么最大也就能存到``l``这个正整数，也就是说最大的缺失正整数可能性为``l+1``
* 2、 ``l+1`` 这个元素我们不用找，如果前面的正整数都存在，那么答案自然就是``l+1``
* 3、咱们可以直接把``nums``中所有负数改为``l+1``，因为咱们想用负数来标记存在的正整数，即``nums[k]``为负数，说明正数``k+1``存在
* 4、遍历``nums``，如果``nums[k]``小于``l``，那么这个正整数是咱们要考虑的，将``nums[k]-1``索引对应的数字改为负数，用于标记``nums[k]``存在
* 5、最后看看所有``nums``位置上，如果对应索引``k``上的数字是不是负数，如果不是负数，说明``k+1``缺失了
* 6、如``2``中所述，如果前面的(``1~l``)正数都有，就返回``l+1``
### 代码
```golang
func firstMissingPositive(nums []int) int {
	n := len(nums)
	for i := 0; i < n; i++ {
		// 因为缺失的数字在1-n之间，把所有负数直接改为大于n的正整数
		if nums[i] <= 0 {
			nums[i] = n + 1
		}
	}
	for i := 0; i < n; i++ {
		num := abs(nums[i])
		// 将小于等于n的正整数，相应索引对应的数字置换为负数
		if num <= n {
			nums[num - 1] = -abs(nums[num - 1])
		}
	}
	// 如果是正数，说明相应位置数字缺失
	for i := 0; i < n; i++ {
		if nums[i] > 0 {
			return i + 1
		}
	}
	return n + 1
}

func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```
## 置换法
### 解题思路
参考了``liweiwei1419``大佬的解法

* 1、``nums``数组长度为``l``，哪怕存的都是最小的正整数，那么最大也就能存到``l``这个正整数，也就是说最大的缺失正整数可能性为``l+1``
* 2、 ``l+1`` 这个元素我们不用找，如果前面的正整数都存在，那么答案自然就是``l+1``
* 3、咱们依次把拿到的小于等于``l``的正整数，放到``nums``的``l-1``索引上
* 4、最后看看所有``nums``位置上，如果对应索引``k``上的数字不是``k+1``，那缺失的就是``k+1``
* 5、如``2``中所述，如果前面的(``1~l``)正数都有，就返回``l+1``
### 代码
```golang
func firstMissingPositive(nums []int) int {
	l := len(nums)
	for i := 0; i < l; i++ {
		// 数字是正整数 / 小于等于l / 没放在正确位置上
		for nums[i] > 0 && nums[i] <= l && nums[nums[i]-1] != nums[i] {
			nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]
		}
	}
	for k, v := range nums {
		if v != k+1 {
			return k + 1
		}
	}
	// 前面的正数都有，就返回l + 1
	return l + 1
}
```
又或者官方解法
