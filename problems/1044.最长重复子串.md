# 1044. 最长重复子串
> 原题链接：[1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

### 解题思路
后缀数组是一个字符串的所有后缀的排序数组。后缀是指从某个位置i开始到整个串末尾结束的一个子串。

字符串``r``的从第``i``个字符开始的后缀表示为``Suffix(i)``，也就是``Suffix(i)=r[i..len(r)]``。

例如：字符串``banana``的所有后缀如下：
```
            对所有后缀排序
            ----------->
0 banana                      5 a
1 anana                       3 ana
2 nana                        1 anana
3 ana                         0 banana
4 na                          4 na
5 a                           2 nana
```
所以``banana``的后缀数组为： ``{5， 3， 1， 0， 4， 2}`` 。

由此可以把找字符串的重复子串的问题转换为从后缀排序数组中，通过对比相邻的两个子串的公共串的长度找出最长的公共串的问题。

在上例中``3:ana``与``1:anana``的最长公共子串为``ana``。这也就是这个字符串的最常公共子串
### 代码
会超时！！！！
```golang
func longestDupSubstring(S string) string {
	l := len(S)
	// 用来存储后缀数组
	suffixes := make([]string, l)
	longestSubStr, longestSubStrLen := "", 0
	// 获取后缀数组
	for i := 0 ; i < l;i++ {
		suffixes[i]=S[i:]
	}
	sort.Strings(suffixes)
	for i := 1; i < l; i++ {
		tmp := maxPrefix(suffixes[i], suffixes[i-1])
		if tmp > longestSubStrLen {
			longestSubStr, longestSubStrLen = suffixes[i][:tmp], tmp
		}
	}
	return longestSubStr
}

// 找出最长的公共子串的长度
func maxPrefix(s1, s2 string) int {
	i := 0
	for i < len(s1) && i < len(s2) {
		if s1[i] == s2[i] {
			i++
		} else {
			break
		}
	}
	return i
}
```
改进使用``rabin-karp``算法，精度不够，长度特别长的不满足
```golang
func longestDupSubstring(S string) string {
	arr := make([]uint64, len(S))
	for k, v := range S {
		arr[k] = uint64(v) - 'a'
	}
	// 二分法
	left, right := 0, len(S)
	for left < right {
		// 向上取整
		mid := left + (right-left+1)/2
		if rabinKarp(arr, mid) > 0 {
			left = mid
		} else {
			right = mid - 1
		}
	}
	start := rabinKarp(arr, left)
	if start == -1 {
		return ""
	}
	return S[start : start+left]
}

const R = uint64(26)       // 系数
const MOD = math.MaxUint32 // 取模的模数
func rabinKarp(arr []uint64, M int) int {
	curHash := uint64(0)
	seen := make(map[uint64]bool)
	// 首先统计0----length-1 这个长为length的的哈希值
	for i := 0; i < M; i++ {
		curHash = (curHash*R + arr[i]) % MOD
	}
	seen[curHash] = true
	// RM 表示R的M次方
	RM := uint64(1)
	// 等价于RM = Math.Pow(R, M-1) % MOD
	for i := 1; i <= M; i++ {
		RM = (RM * R) % MOD
	}
	// 后续计算散列值
	// 统计(1----length) (2------length+1) ............ (arr.length-length -----arr.length-1) 的哈希值
	for start := 1; start <= len(arr)-M; start++ {
		curHash = (curHash*R - arr[start-1]*RM%MOD + MOD) % MOD
		curHash = curHash + arr[start+M-1]%MOD
		if _, ok := seen[curHash]; ok {
			return start
		}
		seen[curHash] = true
	}
	return -1
}
```