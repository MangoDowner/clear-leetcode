# 390. 消除游戏
> ## 栈模拟法 + 递归法

> 原题链接：[390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

## 解法一、栈模拟法
### 解题思路
首先说明，这个算法不会通过，你可以选择直接跳到``解法二``。

有个``100000000``的测试用例，摆明了和我胖虎作对。

所以咱们这里，只是提供个思路。

看到一会儿从左边，一会儿从右边取，就想到颠来倒去，就想到了``栈``:
往里面放的时候正序放，取得时候倒着取。
### 代码
```go
func lastRemaining(n int) int {
	if n == 0 {
		return 0
	}
	var stack []int
	for i := 1; i <= n; i++ {
		stack = append(stack, i)
	}
	for len(stack) >= 2 {
		l := len(stack)
		var tempStack []int
		for i := 0; i < l; i ++ {
			if (l-1-i)%2 == 1 {
				tempStack = append(tempStack, stack[l-1-i])
			}
		}
		stack = tempStack
	}
	return stack[0]
}
```

## 解法二、递归法
### 解题思路
1、如果``n``是奇数，那么假设``n=2k+1``
* 1）如果从左往右
```
1 2 3 4 5 6 ... 2k+1 ->
```
第一次消除后剩余
```
2 4 6 ... 2k <-
```
转换一下，类似于下面的消除，但是所有数字都是其两倍
```
1 2 3 ... k <-
```
所以，这种情况下，结果为
```
f(n/2, 相反方向) * 2
```

2、如果``n``是偶数，那么假设``n=2k``
* 1）如果从左向右
```
1 2 3 4 5 6 ... 2k ->
```
第一次消除后剩余
```
2 4 6 ... 2k <-
```
转换一下，类似于下面的消除，但是所有数字都是其两倍
```
1 2 3 ... k <-
```
所以，这种情况下，结果为
```
f(n/2, 相反方向) * 2
```

* 2）如果从右向左
```
1 2 3 4 5 6 ... 2k <-
```
第一次消除后剩余
```
1 3 5 ... 2k-1 ->
```
转换一下，类似于下面的消除，但是所有数字都加了``1``
```
2 4 6 ... 2k ->
```
再次转换一下，类似于下面的消除，但是所有数字都是其两倍
```
1 2 3 ... k <-
```
所以，这种情况下，结果为
```
f(n/2, 相反方向) * 2 - 1
```

### 代码
```go
func dfs(n int, fromLeft bool) int {
	if n == 1 {
		return 1
	}
	// 如果是奇数的话，从左从右都一样
	if n%2 == 1 {
		return 2 * dfs(n/2, !fromLeft)
	}
	// 如果是偶数,左右消除结果有区分
	if fromLeft {
		return 2 * dfs(n/2, !fromLeft)
	}
	return 2*dfs(n/2, !fromLeft) - 1
}
```
