# 老老实实遍历就完事了
### 解题思路
* 1、从每个有黄金的单元格为起点分别遍历
* 2、遍历方法为上下左右4个方向
* 3、记录已经访问的单元格，防止重复访问
* 4、碰到``边界``/``没有黄金的``/``访问过的``单元格，当前遍历结束
### 代码

```golang
var max int // 最终结果
func getMaximumGold(grid [][]int) int {
	// 记录单元格是否被访问
	visited := make([][]bool, len(grid))
	for k := range visited {
		visited[k] = make([]bool, len(grid[0]))
	}
	max = 0
	// 以每一个有黄金的单元格为起点开始搜索
	for row, v := range grid {
		for col, v1 := range v {
			if v1 != 0 {
				backTrack(row, col, 0, grid, visited)
			}
		}
	}
	return max
}

// row/col 当前的行列 sum 当前的累加黄金 grid 金矿黄金分布 visited单元格访问数组
func backTrack(row, col int, sum int, grid [][]int, visited [][]bool) {
	// 越界/无黄金/已访问 情况排除
	if row < 0 || row >= len(grid) || col < 0 || col >= len(grid[0]) || grid[row][col] == 0 || visited[row][col] {
		return
	}
	// 记得要把当前单元格置为已访问，否则会重复访问
	visited[row][col] = true
	sum += grid[row][col]
	if sum > max {
		max = sum
	}
	// 上下左右四个方向都要照顾到
	backTrack(row-1, col, sum, grid, visited)
	backTrack(row+1, col, sum, grid, visited)
	backTrack(row, col-1, sum, grid, visited)
	backTrack(row, col+1, sum, grid, visited)
	visited[row][col] = false
}
```