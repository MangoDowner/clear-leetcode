# 375.猜数字大小 II.md

> 原题链接：[375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

## 解法一、动态规划
### 解题思路
这题很容易认为是二分法，写出如下代码，但其实并不是...
```golang
func getMoneyAmount(n int) int {
	left, right, guess, result := 1, n, n, 0
	for left <= right {
		mid := left + (right-left)/2
		if mid == guess {
			return result
		} else if mid < guess {
			left = mid + 1
		} else {
			right = mid - 1
		}
		result += mid
	}
	return result
}
```
咱们要用的是动态规划，为什么呢？

因为，使用动态规划，我们可以穷举所有的情况，可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。

举例来说，当``n=5``的时候
```
动态规划：1 2 3 4 5 在第一次猜数时，我们可以猜1,2,3,4,5
二分查找：1 2 3 4 5 在第一次猜数时，我们只能猜3
```
### 代码
```golang
func getMoneyAmount(n int) int {
	memo := make([][]int, n+1)
	for k := range memo {
		memo[k] = make([]int, n+1)
	}
	for l := 2; l <= n; l++ {
		for start := 1; start <= n-l+1; start++ {
			minValue := math.MaxInt32
			for piv := start; piv < start+l-1; piv++ {
				minValue = min(minValue, piv+max(memo[start][piv-1], memo[piv+1][start+l-1]))
			}
			memo[start][start+l-1] = minValue
		}
	}
	return memo[1][n]
}

func max(num1, num2 int) int {
	if num1 > num2 {
		return num1
	}
	return num2
}

func min(num1, num2 int) int {
	if num1 < num2 {
		return num1
	}
	return num2
}
```
## 解法二、回溯法
### 解题思路

参考``RockyPan``思路

* 1、在暴力算法中，我们首先在``(1, n)``中任意挑选一个数字，假设它是个错误的猜测（最坏情况），我们需要用最小代价去猜到需要的数字。那么在一次尝试以后，答案要么在我们猜的数字的左边要么在右边，为了考虑最坏情况，我们需要考虑两者的较大值。因此，如果我们选择``i``作为第一次尝试，总体最小代价是
```
cost(1,n) = i + max(cost(1,i−1), cost(i+1,n))
```
* 2、对``(1, n)``重复这个过程，最终取最小的就是我们要的结果。
* 3、再来看递归的退出。如果在是``2``个中选，我们只需要选小的。如果只是``1``个，根本就不用选了。

### 代码
```golang
var memo map[string]int

func getMoneyAmount(n int) int {
	memo = make(map[string]int)
	return dfs(1, n)
}

func dfs(left, right int) int {
	key := fmt.Sprintf("%d-%d", left, right)
	if value, ok := memo[key]; ok {
		return value
	}
	if right == left {
		return 0
	}
	if right-left == 1 {
		return left
	}
	result := math.MaxInt32
	for i := left; i <= right; i++ {
		result = min(result, i+max(dfs(left, i-1), dfs(i+1, right)))
	}
	memo[key] = result
	return result
}

func max(num1, num2 int) int {
	if num1 > num2 {
		return num1
	}
	return num2
}

func min(num1, num2 int) int {
	if num1 < num2 {
		return num1
	}
	return num2
}
```
