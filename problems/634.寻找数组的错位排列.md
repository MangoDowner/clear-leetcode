# 634. 寻找数组的错位排列
在组合数学中，如果一个排列中所有元素都不在原先的位置上，那么这个排列就被称为错位排列。

给定一个从1 到 n升序排列的数组，你可以计算出总共有多少个不同的错位排列吗？

由于答案可能非常大，你只需要将答案对 10^9+7 取余输出即可。

样例 1:
```
输入: 3
输出: 2
解释: 原始的数组为 [1,2,3]。两个错位排列的数组为 [2,3,1] 和 [3,1,2]。
```

注释:
```
n 的范围是 [1, 10^6]。
```
## 动态规划
### 解题思路
+ 1 首先明确``dp[n]``表示一共有n个元素，每个元素都不能放在自己现在位置的方案数。
+ 2 比如初始状态是``[1,2,3,4,5]``，现在考虑将``1``和后面的元素交换位置，
  那么``1``一共有``n-1``个位置可以选择,假设选中了2与1交换，
  状态变为```[2,1,3,4,5]```，令当前状态(2的位置不能动)的方案数为``K``，
  那么首先你要明白的是，``dp[n]=(n-1)*K``，也就是说，不管1与后面的哪个元素交换，
  交换之后的状态都有``K``种方案数。 
+ 3 怎么求K呢，现在考虑状态```[1,3,4,5]``，这个局面有两种操作方法
  + 一种是``1``不变，变换``[3,4,5]``，这个方案的值就是``dp[n-2]``； 
  + 另一种是``1``也参与进来，那么意味着，每个元素都不能放在现在的位置，
    因此方案数``dp[n-1]``。即``K=dp[n-1]+dp[n-2]``。
### 代码

```csharp
public class Solution {
    public int FindDerangement(int n)
    {
        var dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 0;
        for (var i = 2; i <= n; i++)
        {
            dp[i] = (int)((i - 1L) * (dp[i - 1] + dp[i - 2]) % 1000000007);
        }

        return dp[n];
    }
}
```
