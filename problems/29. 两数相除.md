# 用加法和移位代替乘2
### 解题思路
顺便记录力扣的一个bug...
![力扣bug.PNG](https://pic.leetcode-cn.com/01b8900b4d1f6616f9504df320b40113b9ff0fd29e12b73c07db8363e71902bc-%E5%8A%9B%E6%89%A3bug.PNG)


不能用乘法，咱们就用``加法``和``移位``，总之都能实现``乘2``的功能

思路如下：
1）首先注意越界问题，被除数范围如下
```
[−2^31,  2^31 − 1]
```
当被除数和除数都是负数的时候，被除数最小可以为``−2^31``，当除数为``-1``时，得到的结果为``2^31``就越界了
2）然后我们以``dividend=23 divisor=3``来举例
```
第一步:
3 * 1 = 3 < 23
3 * 2 = 6 < 23
3 * 2 * 2 = 12 < 23
3 * 2 * 2 * 2 = 24 > 23
也就是说，divendend只能容下的divisor数目为
4 < divendend / divisor < 8

第二步:
我们把刚才能容下的4个divisor（即12）减掉，看看剩下的11还能存下几个divisor
这里的做法和第一步类似
3 * 1 = 3 < 11
3 * 2 = 6 < 11
3 * 2 * 2 = 12 > dividend
也就是说，11只能容下的divisor数目为
2 < 11 / divisor < 4

第三步:
我们把刚才能容下的2个divisor（即3）减掉，看看剩下的5还能存下几个divisor
这里的做法和第一步类似
3 * 1 = 3 < 5
3 * 2 = 6 > 5
也就是说，5只能容下的divisor数目为
1 < 5 / divisor < 2

第四步:
我们把刚才能容下的1个divisor（即6）减掉，看看剩下的2还能存下几个divisor
这时候被除数2已经比divisor小了，故而容不下任何divisor了

所以咱们divendend总共能容纳的divisor为：
4 + 2 + 1= 7
```

### 代码

```golang
func divide(dividend int, divisor int) int {
	if divisor == 0 {
		return 0
	}
	// 注意越界问题
	if divisor == -1 && dividend == -(math.MaxInt32+1) {
		return math.MaxInt32
	}
	dividendAbs := int(math.Abs(float64(dividend)))
	divisorAbs := int(math.Abs(float64(divisor)))
	result := div(dividendAbs, divisorAbs)
	// 还原其本来正负
	if (dividend <= 0 && divisor > 0) || (dividend >= 0 && divisor < 0) {
		return -result
	}
	return result
}

func div(dividend int, divisor int) int {
	if dividend < divisor {
		return 0
	}
	sum := 0
	// 只要被除数还比较大就一直循环
	for dividend >= divisor {
		level, originalDivisor, lastDivisor := uint(0), divisor, 0 // X2的次数 / 保存原始的除数 / 保存最后一次够减的数字
		for divisor <= dividend {
			level++
			lastDivisor = divisor
			divisor += divisor
		}
		level-- // 最后一次的X2是超出的，所以-1
		sum += 1 << level // 加上符合的因数
		dividend -= lastDivisor 
		divisor = originalDivisor
	}
	return sum
}
```