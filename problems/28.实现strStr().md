## 暴力查找法
### 代码
```golang
func strStr(haystack string, needle string) int {
	lenHaystack, lenNeedle := len(haystack), len(needle)
	for indexHaystack := 0; indexHaystack <= lenHaystack-lenNeedle; indexHaystack++ {
		indexNeedle := 0
		for ; indexNeedle < lenNeedle; indexNeedle++ {
			if haystack[indexHaystack+indexNeedle] != needle[indexNeedle] {
				break
			}
		}
		// 找到匹配
		if indexNeedle == lenNeedle {
			return indexHaystack
		}
	}
	// 未找到匹配
	return -1
}
```
## 显式回退法
### 代码
```golang
func strStr(haystack string, needle string) int {
	indexHaystack, lenHaystack := 0, len(haystack)
	indexNeedle, lenNeedle := 0, len(needle)
	for indexHaystack, indexNeedle = 0, 0; indexHaystack < lenHaystack && indexNeedle < lenNeedle; indexHaystack++ {
		if haystack[indexHaystack] == needle[indexNeedle] {
			indexNeedle++
		} else {
			indexHaystack -= indexNeedle
			indexNeedle = 0
		}
	}
	// 找到匹配
	if indexNeedle == lenNeedle {
		return indexHaystack - lenNeedle
	}
	// 未找到匹配
	return -1
}
```
## KMP算法
### 代码
```golang
func strStr(haystack string, needle string) int {
	lenHaystack, lenNeedle := len(haystack), len(needle)
	if lenNeedle == 0 {
		return 0
	}
	if lenHaystack == 0 {
		return -1
	}
	next := make([]int, lenNeedle+1)
	// kmp 预处理
	indexNeedle, k := 0, -1
	next[indexNeedle] = k
	for indexNeedle < lenNeedle-1 {
		if k == -1 || needle[indexNeedle] == needle[k] {
			indexNeedle++
			k++
			next[indexNeedle] = k
		} else {
			k = next[k]
		}
	}
	// kmp 搜索
	indexNeedle, indexHaystack := 0, 0
	for indexHaystack < lenHaystack {
		for indexNeedle >= 0 && needle[indexNeedle] != haystack[indexHaystack] {
			indexNeedle = next[indexNeedle]
		}
		indexNeedle++
		indexHaystack++
		// 完全匹配
		if indexNeedle == lenNeedle {
			return indexHaystack - lenNeedle
		}
	}
	return -1
}
```