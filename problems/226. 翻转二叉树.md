# 深度优先和广度优先
## 解法一、深度优先遍历
### 解题思路
对于一个节点来说：
* 1）先分别翻转其左右子节点
* 2）然后将翻转后左右子树进行翻转

就相当于翻转该节点了

### 代码

```golang
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	left, right := invertTree(root.Left), invertTree(root.Right)
	root.Left, root.Right = right, left
	return root
}
```

## 解法二、广度优先遍历
### 解题思路
将所有未交换左右节点的节点都加入一个队列，每次从队列头部取出一个元素，然后交换其左右节点

### 代码

```golang
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	queue := []*TreeNode{root}
	for len(queue) != 0 {
		head := queue[0]
		queue = queue[1:]
		head.Left, head.Right = head.Right, head.Left
		if head.Left != nil {
			queue = append(queue, head.Left)
		}
		if head.Right != nil {
			queue = append(queue, head.Right)
		}
	}
	return root
}
```