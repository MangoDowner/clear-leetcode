# 1524. 和为奇数的子数组数目
> 原题链接：[652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

## 题干
给你一个整数数组arr。请你返回和为 奇数的子数组数目。

由于答案可能会很大，请你将结果对10^9 + 7取余后返回。

示例 1：
```
输入：arr = [1,3,5]
输出：4
解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。
所有子数组的和为 [1,4,9,3,8,5].
奇数和包括 [1,9,3,5] ，所以答案为 4 。
```
示例 2 ：
```
输入：arr = [2,4,6]
输出：0
解释：所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。
所有子数组和为 [2,6,12,4,10,6] 。
所有子数组和都是偶数，所以答案为 0 。
```
示例 3：
```
输入：arr = [1,2,3,4,5,6,7]
输出：16
```
示例 4：
```
输入：arr = [100,100,99,99]
输出：4
```
示例 5：
```
输入：arr = [7]
输出：1
```

提示：
```
1 <= arr.length <= 10^5
1 <= arr[i] <= 100
```
## 前缀和
### 解题思路
+ 1、分别使用``oddNum/evenNum``表示奇数前缀和的数量与偶数前缀和的数量。初始时``oddNum=0``，``evenNum=1``，因为空的前缀的和是``0``，也是偶数前缀和。
+ 2、遍历数组 ``arr`` 并计算前缀和。对于下标 ``i``的位置的前缀和（即``arr[0]+arr[1]+…+arr[i]``），根据奇偶性进行如下操作：
    + 当下标``i``的位置的前缀和是偶数时，如果下标``j``满足``j < i``且下标 ``j``的位置的前缀和是奇数，则从下标``j+1``到下标 ii 的子数组的和是奇数，因此，以下标``i``结尾的子数组中，
    和为奇数的子数组的数量即为奇数前缀和的数量``oddNum``；
    + 当下标``i``的位置的前缀和是奇数时，如果下标 ``j``满足``j < i``且下标``j``的位置的前缀和是偶数，则从下标``j+1``到下标``i``的子数组的和是奇数，因此，以下标``i``结尾的子数组中，
    和为奇数的子数组的数量即为偶数前缀和的数量``evenNum``。
+ 3、上述下标``j``的最小可能取值为 ``-1``，当 ``j=-1`` 时表示下标``j``的位置的前缀为空。
+ 4、在更新和为奇数的子数组数量之后，需要根据下标``i``的位置的前缀和的奇偶性更新``oddNum``或``evenNum``的值。
如果前缀和是奇数，则``oddNum``的值加 1；如果前缀和是偶数，则 ``evenNum``的值加 1。


### 代码
```go
func numOfSubarrays(arr []int) int {
	mod := 1000000007
	oddNum, evenNum, sum := 0, 1, 0
	result := 0
	for _, v := range arr {
		sum += v
		if sum%2 == 0 {
			result = (result + oddNum) % mod
		} else {
			result = (result + evenNum) % mod
		}
		if sum%2 == 0 {
			evenNum++
		} else {
			oddNum++
		}
	}
	return result
}
```
